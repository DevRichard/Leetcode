# 022 Generate Parentheses

Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

>[

>  "((()))",

>  "(()())",

>  "(())()",

>  "()(())",

>  "()()()"

>]

### Solution:

这道题和17题有一种十分的相似，都是根据一个输入扩展出每个位置的不同情况，这种问题我17题用的递归，这道题用的循环，模拟这个问题，之前所用的核心思想是我去遍历这个数组的每一个位置，如果满足要求的话我们就根据当前位置的情况从原来的list中取出之前的内容更新，连接上新的字符然后再放回原来的list中；如果我们一次需要链接多个话，也可以这样取出来再放进去，但是这种方法需要不断的取出和放出，而且对于这道题我们需要考虑左右括号数量的情况，写起来挺麻烦的，时间上也挺很慢。


### Update

后来仔细想了想，这其实就是一个DFS，你其实可以这样想，每一次我们取左括号和右括号可以看作一个一个分支的两端，我们每一次走其中的一端，走到叶子节点后就相当于我们能找到一种满足的情况，所需要的仅仅是中间限制一步不能让左括号数量大雨右括号，这样想的话就问题就变得非常简单来。如果换到17题的话，我们也同样的可以换成每遍历到一个新的数字就转化成3个或者4个的新的节点，然后很轻松的可以用DFS解决。

同样我们延伸去想的话，我们可以把任何带有选择性的最后输出多个不同解决的问题都转化成路径的选择问题，我们这样可以很清楚的利用动态规划解决这一问题。另外，这样的话我们只需要在遍历到叶子节点时将之前的记录输出即可，就不需要对原来的数组不断更新的，节约了时间和空间成本。

# 004 Median of Two Sorted Array
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

### Example 1:
>nums1 = [1, 3]

>nums2 = [2]

>The median is 2.0

### Example 2:
>nums1 = [1, 2]

>nums2 = [3, 4]

>The median is (2 + 3)/2 = 2.5

### Solution:

这道题卡了我好久，主要问题是我跟之前做过的一道题搞混了，老是理所当然的想用二分法，然后在奇偶问题上捣鼓不清，一天也没搞出来。 最简单的思路是用归并merge两个数组，然后去找中位数。 稍微改进一点的是，我们并不实际归并这两个数组，而是单纯的用指针指向我们遍历的位置，交替向后遍历直到找到（m+n）/2这个元素即可。这样的时间复杂度是O(n/2)，虽然通过了测试，但是并没有满足题目中时间复杂度的要求。 *{AC_1}*

### Update1: Find the kth least

我们把这道题转化为求第k小元素，其实思路和我们原来想的二分的方法差不太多，但是只需要从数组的一端进行考虑，这样可以少很多的奇数偶数的讨论，只需要关注其中一端，保证他每次都在一端的第k个就可以了。

我们首先想，我们要得到两个数组的第k小元素，首先就是要比较这两个数组的第k/2的位置这个数字的大小，a[k/2-1] > b[k/2-1],则证明第k小的元素一定不在b这个数组前k/2个里， 如果这些数里有第k小的，那么a这个数组里k/2个肯定有比第k小大的数组，那么找不到k-1比这个小的元素了。所以我们可以放心的删掉这k/2个元素，这样问题变成了在两个个更小的数组寻找k/2小的元素，问题规模缩小了一般，能满足O(logn)的时间复杂度。*{AC_2}*

明白了这个道理之后这道题依然不是特别简单，主要是各种需要考虑的特殊情况。我们首先得想到其中一个数组小于k/4得情况，那么我们就让另外一个数组定位在k/2-length,这样保证了每次删去的一定是k/2个元素。然后考虑边界情况，首先，当两个返回值相等的时候，无论如何在他们前面一定是k个元素，所以我们这个时候返回的肯定是K的值。另外，当k=1，我们返回的是a[0]和a[1]的较大值。最后是如果其中一个数组为空的话，返回另一个数组的k-1即可。

这道题也感觉自己许多代码还和其他人有一定的差距，首先第一个问题是对删除这个事情的定义，和上一道题同样的问题，要学会用指针来删除一个数组，在指针左边得我们就相当与删除了，会节约非常多的时间。另外一个没有处理好的事情是对如果其中一个数组过小的这件事情的处理上，我一开始将一个标记定义在了小数组的末端，另一个依然放在了k/4那个位置上，这样的话就有许多特殊情况需要考虑，比如奇偶和这个时候的元素相等，就特别麻烦，在这上面浪费了许多的时间。最后是网上看到了一个小技巧，我们可以用一步操作判断数组大小，然后重新调用函数，这样的话就保证上面的数组一定比下面大/小，如此就可以节约很多的判断。最后重新写了一遍，感觉比起最开始的来，思路清晰了好多。 *{AC_3}*

这道题前前后后花了整整一天的时间，一方面是这道题真的很棒，需要考虑很多；一方面是自己好久没写代码了，码力大减，之后就好好的吸取这道题带个我的经验和教训，认真努力的码题吧。


### Update2：Divide and Conquer

我们回到我们开始的思路，想一想原来的分治做法可不可以，想了想应该是不可以的，我们寻找第n小的算法成立的原因是因为我们每次能够恰好找到n/2个比其小的元素； 但是我们如果对于长度不想等的两个数组，我们没有办法保证每次除去了等量比他大的和比他小的，这样的话就不满足递归的条件了。如果这两个数组长度相同的话，我们就可以应用直接寻找两个数组的各自中位数进行比较，删除小的中位数的左端和大的中位数的右端，这样就能保证我们每次删除了等量的元素。其实这个做法和寻找第K小的思路方法上很相似，只不过一个每次删除一半的左边和另一半的右边，另外一个是删除第k／2中较小的那个的全部k/2个元素，都是将问题的规模变成了原来的一半。

# 023 Merge k Sorted Lists

Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

### Solution:
这道题简直是我的悲惨世界，自己在众多路中选择路一种最难的办法，一开始看到这个问题想的太复杂了。我当时一看是n路归并就立刻想到用堆，脑海中立马出现的是把n路链表的头放在堆里进行排序，我直接的想法是将原来每个链表第一个最小的元素放入数组中，然后依次删掉最小元素，然后将该列表的下一个元素放入就可以了。但主要问题就出来，如何去寻找原来的元素，我原来想用HashMap去寻找原来链表，但是又出现了重复key值问题，如果key值出现重复但话无法直接用HashMap，如果直接寻找就肯定超时，最后没办法笨拙的用了HashMap来找到ArrayList，最后用PriorityQueue，HashMap，ArrayList三个复杂结构才勉强完成来这道题。

如果除去寻找链表的操作的话，我们只需要维持一个大小为K的堆，一共进行过nk次操作，所以复杂度可以达到O(nklogk), 但是我们又增加来一步对nk个元素寻找原链表的操作，这样的话因为重复元素的存在所以时间复杂度可能远远高于这个，不稳定。

### Update1:
其实这道题我的思路没有错，但重点是我们排序但对象应该变成链表而不是单个数字，我们可以用PriorityQueue中的ListNodeComparator来构造一个针对ListNode的优先对流／堆，这样就避免了再去寻找原链表的复杂操作，其实本来我们可以直接构造这样的堆来搞定。其实这道题不用这么复杂，直接通过分治每次对两个链表进行合并操作，或者从一开始把数组分成两半向下递归，也可以从最底层开始俩俩合并向上递归。这样每一层合并的次数应该是kn次，一共有logk层，这样一共的时间复杂度是O(nklogk),和堆的时间复杂度相同。
